/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef emLogServer_H
#define emLogServer_H

#include <thrift/TDispatchProcessor.h>
#include "NascenseAPI_v01e_types.h"

namespace emInterfaces {

class emLogServerIf {
 public:
  virtual ~emLogServerIf() {}
  virtual void createUniqueExperimentName(std::string& _return, const std::string& baseName) = 0;
  virtual void getLogServerSettings(emLogServerSettings& _return, const std::string& uniqueExperimentName) = 0;
  virtual void log(const emLogServerSettings& logServer, const std::string& message, const emLogEventType::type messageType) = 0;
};

class emLogServerIfFactory {
 public:
  typedef emLogServerIf Handler;

  virtual ~emLogServerIfFactory() {}

  virtual emLogServerIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(emLogServerIf* /* handler */) = 0;
};

class emLogServerIfSingletonFactory : virtual public emLogServerIfFactory {
 public:
  emLogServerIfSingletonFactory(const boost::shared_ptr<emLogServerIf>& iface) : iface_(iface) {}
  virtual ~emLogServerIfSingletonFactory() {}

  virtual emLogServerIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(emLogServerIf* /* handler */) {}

 protected:
  boost::shared_ptr<emLogServerIf> iface_;
};

class emLogServerNull : virtual public emLogServerIf {
 public:
  virtual ~emLogServerNull() {}
  void createUniqueExperimentName(std::string& /* _return */, const std::string& /* baseName */) {
    return;
  }
  void getLogServerSettings(emLogServerSettings& /* _return */, const std::string& /* uniqueExperimentName */) {
    return;
  }
  void log(const emLogServerSettings& /* logServer */, const std::string& /* message */, const emLogEventType::type /* messageType */) {
    return;
  }
};

typedef struct _emLogServer_createUniqueExperimentName_args__isset {
  _emLogServer_createUniqueExperimentName_args__isset() : baseName(false) {}
  bool baseName;
} _emLogServer_createUniqueExperimentName_args__isset;

class emLogServer_createUniqueExperimentName_args {
 public:

  emLogServer_createUniqueExperimentName_args() : baseName() {
  }

  virtual ~emLogServer_createUniqueExperimentName_args() throw() {}

  std::string baseName;

  _emLogServer_createUniqueExperimentName_args__isset __isset;

  void __set_baseName(const std::string& val) {
    baseName = val;
  }

  bool operator == (const emLogServer_createUniqueExperimentName_args & rhs) const
  {
    if (!(baseName == rhs.baseName))
      return false;
    return true;
  }
  bool operator != (const emLogServer_createUniqueExperimentName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const emLogServer_createUniqueExperimentName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class emLogServer_createUniqueExperimentName_pargs {
 public:


  virtual ~emLogServer_createUniqueExperimentName_pargs() throw() {}

  const std::string* baseName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _emLogServer_createUniqueExperimentName_result__isset {
  _emLogServer_createUniqueExperimentName_result__isset() : success(false), err(false) {}
  bool success;
  bool err;
} _emLogServer_createUniqueExperimentName_result__isset;

class emLogServer_createUniqueExperimentName_result {
 public:

  emLogServer_createUniqueExperimentName_result() : success() {
  }

  virtual ~emLogServer_createUniqueExperimentName_result() throw() {}

  std::string success;
  emException err;

  _emLogServer_createUniqueExperimentName_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_err(const emException& val) {
    err = val;
  }

  bool operator == (const emLogServer_createUniqueExperimentName_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const emLogServer_createUniqueExperimentName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const emLogServer_createUniqueExperimentName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _emLogServer_createUniqueExperimentName_presult__isset {
  _emLogServer_createUniqueExperimentName_presult__isset() : success(false), err(false) {}
  bool success;
  bool err;
} _emLogServer_createUniqueExperimentName_presult__isset;

class emLogServer_createUniqueExperimentName_presult {
 public:


  virtual ~emLogServer_createUniqueExperimentName_presult() throw() {}

  std::string* success;
  emException err;

  _emLogServer_createUniqueExperimentName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _emLogServer_getLogServerSettings_args__isset {
  _emLogServer_getLogServerSettings_args__isset() : uniqueExperimentName(false) {}
  bool uniqueExperimentName;
} _emLogServer_getLogServerSettings_args__isset;

class emLogServer_getLogServerSettings_args {
 public:

  emLogServer_getLogServerSettings_args() : uniqueExperimentName() {
  }

  virtual ~emLogServer_getLogServerSettings_args() throw() {}

  std::string uniqueExperimentName;

  _emLogServer_getLogServerSettings_args__isset __isset;

  void __set_uniqueExperimentName(const std::string& val) {
    uniqueExperimentName = val;
  }

  bool operator == (const emLogServer_getLogServerSettings_args & rhs) const
  {
    if (!(uniqueExperimentName == rhs.uniqueExperimentName))
      return false;
    return true;
  }
  bool operator != (const emLogServer_getLogServerSettings_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const emLogServer_getLogServerSettings_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class emLogServer_getLogServerSettings_pargs {
 public:


  virtual ~emLogServer_getLogServerSettings_pargs() throw() {}

  const std::string* uniqueExperimentName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _emLogServer_getLogServerSettings_result__isset {
  _emLogServer_getLogServerSettings_result__isset() : success(false), err(false) {}
  bool success;
  bool err;
} _emLogServer_getLogServerSettings_result__isset;

class emLogServer_getLogServerSettings_result {
 public:

  emLogServer_getLogServerSettings_result() {
  }

  virtual ~emLogServer_getLogServerSettings_result() throw() {}

  emLogServerSettings success;
  emException err;

  _emLogServer_getLogServerSettings_result__isset __isset;

  void __set_success(const emLogServerSettings& val) {
    success = val;
  }

  void __set_err(const emException& val) {
    err = val;
  }

  bool operator == (const emLogServer_getLogServerSettings_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const emLogServer_getLogServerSettings_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const emLogServer_getLogServerSettings_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _emLogServer_getLogServerSettings_presult__isset {
  _emLogServer_getLogServerSettings_presult__isset() : success(false), err(false) {}
  bool success;
  bool err;
} _emLogServer_getLogServerSettings_presult__isset;

class emLogServer_getLogServerSettings_presult {
 public:


  virtual ~emLogServer_getLogServerSettings_presult() throw() {}

  emLogServerSettings* success;
  emException err;

  _emLogServer_getLogServerSettings_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _emLogServer_log_args__isset {
  _emLogServer_log_args__isset() : logServer(false), message(false), messageType(false) {}
  bool logServer;
  bool message;
  bool messageType;
} _emLogServer_log_args__isset;

class emLogServer_log_args {
 public:

  emLogServer_log_args() : message(), messageType((emLogEventType::type)0) {
  }

  virtual ~emLogServer_log_args() throw() {}

  emLogServerSettings logServer;
  std::string message;
  emLogEventType::type messageType;

  _emLogServer_log_args__isset __isset;

  void __set_logServer(const emLogServerSettings& val) {
    logServer = val;
  }

  void __set_message(const std::string& val) {
    message = val;
  }

  void __set_messageType(const emLogEventType::type val) {
    messageType = val;
  }

  bool operator == (const emLogServer_log_args & rhs) const
  {
    if (!(logServer == rhs.logServer))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(messageType == rhs.messageType))
      return false;
    return true;
  }
  bool operator != (const emLogServer_log_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const emLogServer_log_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class emLogServer_log_pargs {
 public:


  virtual ~emLogServer_log_pargs() throw() {}

  const emLogServerSettings* logServer;
  const std::string* message;
  const emLogEventType::type* messageType;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _emLogServer_log_result__isset {
  _emLogServer_log_result__isset() : err(false) {}
  bool err;
} _emLogServer_log_result__isset;

class emLogServer_log_result {
 public:

  emLogServer_log_result() {
  }

  virtual ~emLogServer_log_result() throw() {}

  emException err;

  _emLogServer_log_result__isset __isset;

  void __set_err(const emException& val) {
    err = val;
  }

  bool operator == (const emLogServer_log_result & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const emLogServer_log_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const emLogServer_log_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _emLogServer_log_presult__isset {
  _emLogServer_log_presult__isset() : err(false) {}
  bool err;
} _emLogServer_log_presult__isset;

class emLogServer_log_presult {
 public:


  virtual ~emLogServer_log_presult() throw() {}

  emException err;

  _emLogServer_log_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class emLogServerClient : virtual public emLogServerIf {
 public:
  emLogServerClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  emLogServerClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void createUniqueExperimentName(std::string& _return, const std::string& baseName);
  void send_createUniqueExperimentName(const std::string& baseName);
  void recv_createUniqueExperimentName(std::string& _return);
  void getLogServerSettings(emLogServerSettings& _return, const std::string& uniqueExperimentName);
  void send_getLogServerSettings(const std::string& uniqueExperimentName);
  void recv_getLogServerSettings(emLogServerSettings& _return);
  void log(const emLogServerSettings& logServer, const std::string& message, const emLogEventType::type messageType);
  void send_log(const emLogServerSettings& logServer, const std::string& message, const emLogEventType::type messageType);
  void recv_log();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class emLogServerProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<emLogServerIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (emLogServerProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_createUniqueExperimentName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getLogServerSettings(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_log(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  emLogServerProcessor(boost::shared_ptr<emLogServerIf> iface) :
    iface_(iface) {
    processMap_["createUniqueExperimentName"] = &emLogServerProcessor::process_createUniqueExperimentName;
    processMap_["getLogServerSettings"] = &emLogServerProcessor::process_getLogServerSettings;
    processMap_["log"] = &emLogServerProcessor::process_log;
  }

  virtual ~emLogServerProcessor() {}
};

class emLogServerProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  emLogServerProcessorFactory(const ::boost::shared_ptr< emLogServerIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< emLogServerIfFactory > handlerFactory_;
};

class emLogServerMultiface : virtual public emLogServerIf {
 public:
  emLogServerMultiface(std::vector<boost::shared_ptr<emLogServerIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~emLogServerMultiface() {}
 protected:
  std::vector<boost::shared_ptr<emLogServerIf> > ifaces_;
  emLogServerMultiface() {}
  void add(boost::shared_ptr<emLogServerIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void createUniqueExperimentName(std::string& _return, const std::string& baseName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createUniqueExperimentName(_return, baseName);
    }
    ifaces_[i]->createUniqueExperimentName(_return, baseName);
    return;
  }

  void getLogServerSettings(emLogServerSettings& _return, const std::string& uniqueExperimentName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getLogServerSettings(_return, uniqueExperimentName);
    }
    ifaces_[i]->getLogServerSettings(_return, uniqueExperimentName);
    return;
  }

  void log(const emLogServerSettings& logServer, const std::string& message, const emLogEventType::type messageType) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->log(logServer, message, messageType);
    }
    ifaces_[i]->log(logServer, message, messageType);
  }

};

} // namespace

#endif
